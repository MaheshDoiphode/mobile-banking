features
User Authentication: Users can register and log in to the application. The authentication process is secure and ensures that only registered users can access the application.

User Dashboard: Once logged in, users are taken to a dashboard where they can view their account details and other relevant information.

Transaction Management: Users can view their transaction history, including details of each transaction such as the transaction ID, receiver ID, payment type, amount, status, and timestamp. They can also see their remaining balance.

Category-based Spending: The application categorizes transactions based on predefined  CategoriesM, allowing users to track their spending in each category. This feature helps users understand their spending habits and manage their finances more effectively.



We are assuming that the user already have some UserAccounts and when user registers on our platform his Accounts will be linked directly to the UserAccountDetailsS table which already stores his accounts.

project will use 2 different databases. 

mongo and mssql.

the mssql will have 3 tables.

we will be using the following in the databases

public class UserDetailsS
{
    [Key]
    public string UserID { get; set; }
    public string Name { get; set; }
    public string Email { get; set; }
    public string Password { get; set; }
    public string PhoneNumber { get; set; }
    public string Address { get; set; }
    public DateTime DateOfBirth { get; set; }
    public string Gender { get; set; }
    public string Nationality { get; set; }
    public byte[] ProfilePhoto { get; set; }
    public DateTime RegistrationDate { get; set; }
    public string RegistrationIP { get; set; }
}

__
public class UserAccountDetailsS
{
    [Key, Column(Order = 0)]
    public string AccountID { get; set; }
    [Key, Column(Order = 1)]
    public string PhoneNumber { get; set; }
    [ForeignKey("UserID")]
    public string UserID { get; set; }
    public string AccountNumber { get; set; }
    public float Balance { get; set; }
    public string AccountType { get; set; }
    public string BankName { get; set; }
    public string IFSCCode { get; set; }
    public string BranchAddress { get; set; }
}

__
public class UserLoginDetailsS
{
    [Key]
    public int LoginID { get; set; }
    [ForeignKey("UserID")]
    public int UserID { get; set; }
    public DateTime LoginTime { get; set; }
    public DateTime LogoutTime { get; set; }
    public string JWToken { get; set; }
    public DateTime OTPGenerationTime { get; set; }
    public string SecretKey { get; set; }
    public string IPAddress { get; set; }
}

____

MongoDB - 
(We will not have autogenerated objectId of the mongoDB instead we will manually give the id. like [BsonId]
        [BsonRepresentation(BsonType.String)] this)

__
Collection 1: TransactionDetailsM 


This collection will store each and every transaction done by the user minus int shows debit else credit.
For every transaction done by someone UserAccountDetailsS will get updated, it will check the AccountNumber and add the transaction amount to the Balance field. Then TransactionDetailsM Collection will get updated and also  CategoriesM Collection will get updated (For all the transactions we have 4  CategoriesM - Groceries, Transport, Entertainment, Others. When user does a transaction we will randomly generate a category and the transaction will get added to the  CategoriesM Collection accordingly as well.)
The Frequency Collection basically stores 5 top users with whome the user has done the transactions. Every time a transaction is done then the Frequency Collection will check if the SenderID exists in the document and if it exists just increment by 1 else it will add it and assign value 1 (it also maintains a list which stores top 5 SenderID. When the SenderID is incremented/added in the document it will check if the value has got greater than any of the SenderID in the list if yes then it will replace it with the new SenderID)


{
  "<AccountIDfromtheUserAccountDetailsTableSQL>": [
    {
          "TransactionID": "<GeneratedBasedOnAlgorithm-CombinationOfAccountIDAndSomeRandomButSequentialText>",
      "ReceiverID": "<TheAccountIDFromUserDetailsTableToSendMoneyToSQL>",
      "PaymentType": "UPI",
      "Amount": -500,
      "Status": "Success",
      "ErrorDescription": "",
      "Timestamp": "2023-06-13T12:34:56Z",
      "RemainingBalance": 1500
    },
    {
      "TransactionID": "124",
      "ReceiverID": "<TheAccountIDFromUserDetailsTableToSendMoneyToSQL>",
      "PaymentType": "RTGS",
      "Amount": 1000,
      "Status": "Failed",
      "ErrorDescription": "Low Balance",
      "Timestamp": "2023-06-14T10:20:30Z",
      "RemainingBalance": 500
    }
  ]
}
__

Collection 2 :  CategoriesM
{
  "<AccountIDfromtheUserAccountDetailsTableSQL>": {
    "Groceries": {
      "Transactions": [
        {
          "TransactionID": "<GeneratedBasedOnAlgorithm-CombinationOfAccountIDAndSomeRandomButSequentialText>",
          "Amount": 200,
          "Timestamp": "2023-06-13T12:34:56Z",
	  "AccountNumber" : <AccountNumberFromUserAccountsDetailsTableSQL>
        },
        {
          "TransactionID": "<GeneratedBasedOnAlgorithm-CombinationOfAccountIDAndSomeRandomButSequentialText>",
          "Amount": -300,
          "Timestamp": "2023-06-14T12:34:56Z",
	"AccountNumber" : <AccountNumberFromUserAccountsDetailsTableSQL>
        }
      ]
    },
    "Entertainment": {
      "Transactions": [
        {
          "TransactionID": "<GeneratedBasedOnAlgorithm-CombinationOfAccountIDAndSomeRandomButSequentialText>",
          "Amount": -400,
          "Timestamp": "2023-06-13T12:34:56Z",
	"AccountNumber" : <AccountNumberFromUserAccountsDetailsTableSQL>
        },
        {
          "TransactionID": "<GeneratedBasedOnAlgorithm-CombinationOfAccountIDAndSomeRandomButSequentialText>",
          "Amount": 3000,
          "Timestamp": "2024-06-14T12:34:56Z",
	"AccountNumber" : <AccountNumberFromUserAccountsDetailsTableSQL>
        }
      ]
    }
  }
}

__

Collection 3: FrequencyM
{
  "<AccountIDfromtheUserAccountDetailsTableSQL>": {
    "favorite": ["<SenderID1>", "<SenderID2>", null, null, null],
    "<SendersID>": 1,
    "SenderID2": 2
  }
}

API Contracts -

User Management Controller - 

1. Register User - 

Req Body :
{
  "userID": "string",
  "name": "string",
  "email": "string",
  "password": "string",
  "phoneNumber": "string",
  "address": "string",
  "dateOfBirth": "2023-07-02T17:46:39.475Z",
  "gender": "string",
  "nationality": "string",
  "profilePhoto": "string",
  "registrationDate": "2023-07-02T17:46:39.475Z",
  "registrationIP": "string"
}

Res body  : Just the status is fine.

2.  Login
This will verify the email and password and update the UserLoginDetailsS table with the IP, LoginTime, a random generated JWTToken(dont focus on this now), OTPGenerationTime (randomly generate this also) and SecretKey also generate and populate in the Table.
Req Body :
{
"email": "string",
  "password": "string",
"registrationIP" : string
}
Res body :
 The UserDetails,  UserAccountDetails tables. 

3. UserDetailsByID
this will fetch data from UserDetailsS and UserAccountDetailsS table. 
Req Parameter : UserID - string
Res Body :
 The UserDetails,  UserAccountDetails tables. 

4. AccountDetailsByID
this will fetch data from  UserAccountDetailsS table. 
Req Parameter : UserID - string
Res Body:
UserAccountDetails table.

5. UpdateUser:
This will update the data in the UserDetailsS table. 
Req Body :
{
  "name": "string",
  "email": "string",
  "password": "string",
  "phoneNumber": "string",
  "address": "string",
  "dateOfBirth": "2023-07-04T06:49:19.368Z",
  "gender": "string",
  "nationality": "string",
  "profilePhoto": "string",
  "registrationDate": "2023-07-04T06:49:19.368Z",
  "registrationIP": "string"
}

Res Body:
{
  "name": "string",
  "email": "string",
  "password": "string",
  "phoneNumber": "string",
  "address": "string",
  "dateOfBirth": "2023-07-04T06:49:19.368Z",
  "gender": "string",
  "nationality": "string",
  "profilePhoto": "string",
  "registrationDate": "2023-07-04T06:49:19.368Z",
  "registrationIP": "string"
}

6. Logout
This will update the UserLoginDetailsS table with the current DateTime with LogoutTime field.
Req Body: UserID - string
Res Body: Status of the request. 
____
TransactionManagement Controller
1. Create Transaction :
this will use UserDetailsS, UserAccountDetailsS, TransactionDetailsM, CategoriesM, FrequencyM tables and collections to verify and add data accodingly.
Req Body:
{
 "UserID": "string",
"transaction": [
    {
      "receiverID": "string",
	"AccountNumber": "string"
      "amount": 3,
	"IFSC Code" : "string",
"paymentType": "string"
    }
  ]
}
When this api is called it will check if the receiverId and all details are correct.
For every transaction done by someone UserAccountDetailsS will get updated, it will check the AccountNumber and add the transaction amount to the Balance field of that AccountNumber in the UserAccountDetails table. Then TransactionDetailsM Collection will get updated and also  CategoriesM Collection will get updated (For all the transactions we have 4  CategoriesM - Groceries, Transport, Entertainment, Others. When user does a transaction we will randomly generate a category in .net when the above api is called and the transaction will get pushed to the  CategoriesM Collection accordingly as well.)
The TransactionId we will generate in the .net with the combination of AccountID and some RandomSequential Text and a increment number.
The Frequency Collection basically stores 5 top users with whome the user has done the transactions. Every time a transaction is done then the Frequency Collection will check if the SenderID exists in the document and if it exists just increment by 1 else it will add it and assign value 1 (it also maintains a list which stores top 5 SenderID. When the SenderID is incremented/added in the document it will check if the value has got greater than any of the SenderID in the list if yes then it will replace it with the new SenderID)

2. GetTransactionByID :
this will fetch data from TransactionDetailsM collection. 
Req Paramater : TransactionID - string
Res Body:
 {
      "TransactionID": "string",
      "ReceiverID": "<TheAccountIDFromUserDetailsTableToSendMoneyToSQL>",
      "PaymentType": "RTGS",
      "Amount": 1000,
      "Status": "Failed",
      "ErrorDescription": "Low Balance",
      "Timestamp": "2023-06-14T10:20:30Z",
      "RemainingBalance": 500
    }

3. GetAllTransaction:
this will fetch data from TransactionDetailsM collection. 

Req Parameter : UserID - string
Res Body:
{
  "<AccountIDfromtheUserAccountDetailsTableSQL>": [
    {
          "TransactionID": "<GeneratedBasedOnAlgorithm-CombinationOfAccountIDAndSomeRandomButSequentialText>",
      "ReceiverID": "<TheAccountIDFromUserDetailsTableToSendMoneyToSQL>",
      "PaymentType": "UPI",
      "Amount": -500,
      "Status": "Success",
      "ErrorDescription": "",
      "Timestamp": "2023-06-13T12:34:56Z",
      "RemainingBalance": 1500
    },
    {
      "TransactionID": "124",
      "ReceiverID": "<TheAccountIDFromUserDetailsTableToSendMoneyToSQL>",
      "PaymentType": "RTGS",
      "Amount": 1000,
      "Status": "Failed",
      "ErrorDescription": "Low Balance",
      "Timestamp": "2023-06-14T10:20:30Z",
      "RemainingBalance": 500
    }
  ]
}

____

ExpenseManagementController.

1. GetAllExpenseByCategory :
this will fetch data from CategoriesM collection. 
req Body: CategoryName - string
Res body : 

"<CategoryNameInTheParameter>": {
      "Transactions": [
        {
          "TransactionID": "<GeneratedBasedOnAlgorithm-CombinationOfAccountIDAndSomeRandomButSequentialText>",
          "Amount": 200,
          "Timestamp": "2023-06-13T12:34:56Z",
	  "AccountNumber" : <AccountNumberFromUserAccountsDetailsTableSQL>
        },
        {
          "TransactionID": "<GeneratedBasedOnAlgorithm-CombinationOfAccountIDAndSomeRandomButSequentialText>",
          "Amount": -300,
          "Timestamp": "2023-06-14T12:34:56Z",
	"AccountNumber" : <AccountNumberFromUserAccountsDetailsTableSQL>
        }
      ]
    }



2. GetFavourites :
this will fetch data from FrequencyM collection. 
Req Parameter : UserID - string 
Res Body : 
{
  "favorite": ["<SenderID1>", "<SenderID2>", null, null, null],
}

____



UserManagementController

POST /api/user/register - Register a new user
POST /api/user/login - Login a user
GET /api/user/{userId} - Get user details by user ID
GET /api/user/account/{userId} - Get account details by user ID
PUT /api/user/update - Update user details
POST /api/user/logout - Logout a user
TransactionManagementController

POST /api/transaction/create - Create a new transaction
GET /api/transaction/{transactionId} - Get transaction details by transaction ID
GET /api/transaction/all/{userId} - Get all transactions for a user
ExpenseManagementController

GET /api/expense/category/{categoryName} - Get all expenses by category
GET /api/expense/favourites/{userId} - Get favourite transactions for a user


__

v0.2

__

implemented all the controllers. 
v0.3 -

Sure, let's break down the flow of the application:

Controllers: Controllers are the entry point for handling a request in an ASP.NET Core application. They are responsible for handling incoming HTTP requests and returning HTTP responses to the client. In your application, you have three controllers: UserManagementController, TransactionManagementController, and ExpenseManagementController. Each controller corresponds to a specific area of your application: user management, transaction management, and expense management.

Services: Services contain the business logic of your application. They are called by the controllers to perform specific tasks like registering a user, logging in a user, creating a transaction, getting transaction details, etc. Services often depend on repositories to access data.

Repositories: Repositories are responsible for data access. They interact with the database directly to fetch or store data. In your application, you have repositories corresponding to each service: UserManagementRepository, TransactionManagementRepository, and ExpenseManagementRepository.

Models: Models represent the data in your application. They define the schema for the tables in your database and the shape of the data in your application.

Here's a simplified flow of a request in your application:

A client (like your Angular application) sends an HTTP request to your application.
The request is received by the appropriate controller based on the route.
The controller calls the appropriate service method to handle the request.
The service method may call a repository method to fetch or store data.
The repository interacts with the database and returns the data to the service.
The service processes the data and returns the result to the controller.
The controller sends the result back to the client as an HTTP response.
For example, when a user logs in:

The client sends a POST request to /api/user/login with the user's email and password in the request body.
The LoginUser method in the UserManagementController is called.
The controller calls the LoginUser method in the UserManagementService, passing the email and password.
The service calls the GetUser method in the UserManagementRepository to fetch the user with the given email.
The repository fetches the user from the UserDetailsS table in the database and returns the user to the service.
The service checks if the password is correct. If it is, it generates a JWT token, OTP, and secret key, and creates a new UserLoginDetailsS record.
The service calls the AddLoginDetails method in the UserManagementRepository to store the new UserLoginDetailsS record.
The repository adds the new record to the UserLoginDetailsS table in the database.
The service returns the user details to the controller.
The controller sends the user details back to the client as an HTTP response.
This flow ensures a clean separation of concerns in your application. Each part of your application has a specific job: controllers handle HTTP requests and responses, services contain business logic, and repositories handle data access. This makes your application easier to understand, test, and maintain.


____



We will not add a new collection in the mongo 
analyze the below json.
this is how i was talking to save multiple transactions in the mongo TransactionDetailsM collection.
Evry time a new transaction is done it will be pushed to the Transactions List like below.
     {
        "_id": "321",
        "Transactions": [
          {
            "TransactionID": "b8258537-87af-447f-ab7b-4e7db3d9c657",
            "UserID": "321",
            "PaymentType": "upi",
            "AccountNumber": "0123456789",
            "Amount": -5000,
            "Status": "Pending",
            "ErrorDescription": "",
            "Timestamp": {
              "$date": "2023-07-05T23:12:13.828Z"
            },
          }
        ]
        "RemainingBalance": -4000
      }


OTP Problem - invalidate the old one.




___


